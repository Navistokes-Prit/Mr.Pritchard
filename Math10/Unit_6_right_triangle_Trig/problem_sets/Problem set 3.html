<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Math Quiz with Floating Whiteboard Tools</title>
  
  <!-- MathJax for LaTeX -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async 
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <link rel="stylesheet" href="../../../css/math10problemset.css" />
  
 
</head>
<body>
  <!-- Help Box -->
  <div id="help-box">
    <button id="help-box-toggle">Minimize</button>
    <h3>How to Type</h3>
    <p><strong>Fractions:</strong> <code>\frac{numerator}{denominator}</code></p>
    <p><strong>Exponents:</strong> <code>x^{2}</code> or <code>(xy)^{3}</code></p>
    <p><strong>Square Roots:</strong> <code>\sqrt{radicand}</code></p>
    <p><strong>NthRoots:</strong> <code>\sqrt[index]{radicand}</code></p>
    <p><strong>Multiplication:</strong> <code>\cdot</code></p>
    <p><strong>Repeating:</strong> <code>\overline{number}</code></p>
  </div>

  <!-- Floating Toolbar -->
  <div id="floating-toolbar">
    <button class="tool-button" data-tool="pencil" data-color="black" 
      style="background-color: black; color: white;">Black</button>
    <button class="tool-button" data-tool="pencil" data-color="red" 
      style="background-color: red; color: white;">Red</button>
    <button class="tool-button" data-tool="pencil" data-color="blue" 
      style="background-color: blue; color: white;">Blue</button>
    <button class="tool-button" data-tool="pencil" data-color="green" 
      style="background-color: green; color: white;">Green</button>
    <button class="tool-button" data-tool="eraser">Eraser Tool</button>
    <button class="tool-button" data-tool="line">Line Tool</button>
    <label for="pencil-size">Pencil and Eraser Size:</label>
    <input type="range" id="pencil-size" min="1" max="20" value="2">
    <button class="tool-button" id="undo-btn">Undo</button>
  </div>

  <!-- Banner -->
  <div id="banner">
    <h2>MATH 10</h2>
    <a class="cta-button" href="../Unit_6_right_triangle_trig.html">Back</a>
  </div>

  <!-- Quiz Section -->
  <div id="quiz-section">
    <!-- Questions will be added dynamically here -->
  </div>

  <!-- Score Section -->
  <div id="score-section">
    <p>Correct Answers: <span class="score" id="correct-score">0</span>/<span id="total-questions">0</span></p>
    <p>Percentage: <span class="score" id="percentage-score">0%</span></p>
  </div>

  <script>
    // Help Box Toggle
    const helpBox = document.getElementById('help-box');
    const toggleButton = document.getElementById('help-box-toggle');
    toggleButton.addEventListener('click', () => {
      helpBox.classList.toggle('minimized');
      toggleButton.textContent = helpBox.classList.contains('minimized') ? 'Maximize' : 'Minimize';
    });

    const quizSection = document.getElementById('quiz-section');
    const correctScoreElement = document.getElementById('correct-score');
    const totalQuestionsElement = document.getElementById('total-questions');
    const percentageScoreElement = document.getElementById('percentage-score');
    let correctAnswers = 0;
    let questionIndex = 0;
    let questions = [];

    // Global active canvas variable for the floating toolbar
    let activeCanvas = null;

    // When a whiteboard canvas is clicked, mark it as active
    document.addEventListener('click', (e) => {
      if (e.target.tagName === 'CANVAS' && e.target.classList.contains('drawing-canvas')) {
        activeCanvas = e.target;
      }
    });

    // Floating toolbar button events (with active tool checkmark)
    document.querySelectorAll('#floating-toolbar .tool-button').forEach(button => {
      button.addEventListener('click', () => {
        // Remove active state from all toolbar buttons (except for undo)
        if (button.id !== 'undo-btn') {
          document.querySelectorAll('#floating-toolbar .tool-button')
                  .forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
        }
        
        if (!activeCanvas) {
          alert('Please click on a whiteboard to activate it.');
          return;
        }
        const tool = button.getAttribute('data-tool');
        if (tool) {
          activeCanvas.dataset.tool = tool;
          // Set color if specified
          const color = button.getAttribute('data-color');
          if (color) {
            activeCanvas.dataset.color = color;
          }
        }
        if (button.id === 'undo-btn') {
          undoAction(activeCanvas);
        }
      });
    });

    // Update pencil size from the global slider
    document.getElementById('pencil-size').addEventListener('input', (e) => {
      if (activeCanvas) {
        activeCanvas.dataset.pencilSize = e.target.value;
      }
    });

    // Debounce helper to reduce MathJax rendering frequency
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => { func.apply(this, args); }, delay);
      };
    }

    // Draw grid lines over the entire canvas (900x600)
    function drawGrid(canvasId, gridSize) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function clearGrid(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function undoAction(canvas) {
      if (!canvas.undoStack || canvas.undoStack.length === 0) return;
      canvas.undoStack.pop();
      const ctx = canvas.getContext("2d");
      if (canvas.undoStack.length > 0) {
        const previousState = canvas.undoStack[canvas.undoStack.length - 1];
        ctx.putImageData(previousState, 0, 0);
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      localStorage.setItem(canvas.id, canvas.toDataURL());
    }

    // Create a new question with a whiteboard (no individual toolbar)
    function createQuestion(questionText, correctAnswersList) {
      let currentIndex = questionIndex++;
      const container = document.createElement('div');
      container.classList.add('question-container');
      container.id = `question${currentIndex}`;

      // Question content (text, input, submit, etc.)
      const questionContent = document.createElement('div');
      questionContent.classList.add('question-content');

      const questionElem = document.createElement('div');
      questionElem.classList.add('question');
      questionElem.innerHTML = `<span class="question-number">${currentIndex + 1}.</span> ${questionText}`;
      questionContent.appendChild(questionElem);

      const inputBox = document.createElement('input');
      inputBox.type = 'text';
      inputBox.classList.add('answer-box');
      inputBox.id = `answer-box-${currentIndex}`;
      inputBox.placeholder = "Your answer";
      questionContent.appendChild(inputBox);

      const latexOutput = document.createElement('div');
      latexOutput.classList.add('answer-latex');
      latexOutput.id = `answer-latex-${currentIndex}`;
      questionContent.appendChild(latexOutput);

      const submitButton = document.createElement('button');
      submitButton.classList.add('submit-button');
      submitButton.textContent = "Submit";
      submitButton.onclick = function () { checkAnswer(currentIndex); };
      questionContent.appendChild(submitButton);

      const feedback = document.createElement('div');
      feedback.classList.add('feedback');
      feedback.id = `feedback-${currentIndex}`;
      questionContent.appendChild(feedback);

      const attemptCounter = document.createElement('div');
      attemptCounter.classList.add('attempt-counter');
      attemptCounter.id = `attempt-counter-${currentIndex}`;
      attemptCounter.textContent = `Attempts: 0`;
      questionContent.appendChild(attemptCounter);

      container.appendChild(questionContent);

      // Whiteboard container with layered canvases: grid, drawing, and preview (for eraser)
      const whiteboardContainer = document.createElement('div');
      whiteboardContainer.classList.add('whiteboard-container');
      const canvasContainer = document.createElement('div');
      canvasContainer.classList.add('canvas-container');

      // Grid canvas (900x600)
      const gridCanvas = document.createElement('canvas');
      gridCanvas.id = `grid-${currentIndex}`;
      gridCanvas.width = 900;
      gridCanvas.height = 600;
      gridCanvas.classList.add('grid-canvas');
      gridCanvas.style.pointerEvents = "none";
      canvasContainer.appendChild(gridCanvas);

      // Drawing canvas
      const drawingCanvas = document.createElement('canvas');
      drawingCanvas.id = `whiteboard-${currentIndex}`;
      drawingCanvas.width = 900;
      drawingCanvas.height = 600;
      drawingCanvas.classList.add('drawing-canvas');
      drawingCanvas.undoStack = [];
      drawingCanvas.dataset.tool = "pencil";
      drawingCanvas.dataset.color = "black";
      drawingCanvas.dataset.pencilSize = "2";
      canvasContainer.appendChild(drawingCanvas);

      // Preview canvas for eraser (on top)
      const previewCanvas = document.createElement('canvas');
      previewCanvas.id = `preview-${currentIndex}`;
      previewCanvas.width = 900;
      previewCanvas.height = 600;
      previewCanvas.classList.add('preview-canvas');
      previewCanvas.style.pointerEvents = "none";
      canvasContainer.appendChild(previewCanvas);

      whiteboardContainer.appendChild(canvasContainer);

      // Clear button
      const clearButton = document.createElement('button');
      clearButton.textContent = "Clear Whiteboard";
      clearButton.classList.add('clear-button');
      clearButton.onclick = function () {
        clearWhiteboard(`whiteboard-${currentIndex}`);
        drawingCanvas.undoStack = [];
        localStorage.removeItem(drawingCanvas.id);
      };
      whiteboardContainer.appendChild(clearButton);

      // Grid selector
      const gridSelector = document.createElement('div');
      gridSelector.classList.add('grid-selector');
      const gridLabel = document.createElement('label');
      gridLabel.setAttribute("for", `grid-select-${currentIndex}`);
      gridLabel.textContent = "Grid:";
      gridSelector.appendChild(gridLabel);

      const gridSelect = document.createElement('select');
      gridSelect.id = `grid-select-${currentIndex}`;
      const gridOptions = [
         { value: "none", label: "No Grid" },
         { value: "10", label: "Small Grid (10px)" },
         { value: "20", label: "Medium Grid (20px)" },
         { value: "50", label: "Large Grid (50px)" }
      ];
      gridOptions.forEach(opt => {
         const optionElem = document.createElement('option');
         optionElem.value = opt.value;
         optionElem.textContent = opt.label;
         gridSelect.appendChild(optionElem);
      });
      gridSelector.appendChild(gridSelect);
      whiteboardContainer.appendChild(gridSelector);

      container.appendChild(whiteboardContainer);
      quizSection.appendChild(container);

      // Restore saved drawing if available
      const savedDrawing = localStorage.getItem(`whiteboard-${currentIndex}`);
      if (savedDrawing) {
        const ctx = drawingCanvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, 0, 0);
        };
        img.src = savedDrawing;
      }

      // Setup whiteboard drawing with preview for eraser
      setupWhiteboard(`whiteboard-${currentIndex}`, `preview-${currentIndex}`);

      // Update LaTeX rendering on answer input
      inputBox.addEventListener('input', debounce(function () {
        const latexOutputElement = document.getElementById(`answer-latex-${currentIndex}`);
        latexOutputElement.innerHTML = `$$${inputBox.value}$$`;
        MathJax.typeset();
      }, 300));

      inputBox.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') { checkAnswer(currentIndex); }
      });

      gridSelect.addEventListener('change', function() {
         const value = gridSelect.value;
         const gridCanvasId = `grid-${currentIndex}`;
         if (value === "none") {
            clearGrid(gridCanvasId);
         } else {
            drawGrid(gridCanvasId, parseInt(value));
         }
      });

      questions.push({ answers: correctAnswersList, answered: false, attempts: 0 });
      updateQuestionNumbers();
    }

    // Setup whiteboard drawing with eraser preview support
    function setupWhiteboard(canvasId, previewCanvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      const previewCanvas = document.getElementById(previewCanvasId);
      const previewCtx = previewCanvas.getContext("2d");
      let drawing = false;
      let startX, startY;
      let savedImageData = null;

      if (!canvas.undoStack) { canvas.undoStack = []; }

      function startDrawing(x, y) {
        drawing = true;
        ctx.beginPath();
        ctx.moveTo(x, y);
        if (canvas.dataset.tool === "eraser") {
          ctx.strokeStyle = "white";
          ctx.lineWidth = canvas.dataset.pencilSize ? parseInt(canvas.dataset.pencilSize) * 2 : 10;
        } else {
          ctx.strokeStyle = canvas.dataset.color || "black";
          ctx.lineWidth = canvas.dataset.pencilSize ? parseInt(canvas.dataset.pencilSize) : 2;
        }
      }

      function draw(x, y) {
        if (!drawing) return;
        if (canvas.dataset.tool !== "line") {
          ctx.lineTo(x, y);
          ctx.stroke();
        }
      }

      function finalizeStroke() {
        canvas.undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        localStorage.setItem(canvas.id, canvas.toDataURL());
      }

      function stopDrawing(x, y) {
        if (!drawing) return;
        if (canvas.dataset.tool === "line") {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.putImageData(savedImageData, 0, 0);
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.strokeStyle = canvas.dataset.color || "black";
          ctx.lineWidth = canvas.dataset.pencilSize ? parseInt(canvas.dataset.pencilSize) : 2;
          ctx.stroke();
          drawing = false;
          savedImageData = null;
          finalizeStroke();
        } else {
          drawing = false;
          finalizeStroke();
        }
      }

      canvas.addEventListener("mousedown", (e) => {
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        if (canvas.dataset.tool === "line") {
          startX = e.offsetX;
          startY = e.offsetY;
          drawing = true;
          savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } else {
          startDrawing(e.offsetX, e.offsetY);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (canvas.dataset.tool === "eraser" && !drawing) {
          previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
          previewCtx.beginPath();
          const eraserSize = canvas.dataset.pencilSize ? parseInt(canvas.dataset.pencilSize) * 2 : 10;
          previewCtx.arc(e.offsetX, e.offsetY, eraserSize / 2, 0, 2 * Math.PI);
          previewCtx.setLineDash([5, 3]);
          previewCtx.strokeStyle = "gray";
          previewCtx.stroke();
          return;
        } else {
          previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }
        if (!drawing) return;
        if (canvas.dataset.tool === "line") {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.putImageData(savedImageData, 0, 0);
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(e.offsetX, e.offsetY);
          ctx.strokeStyle = canvas.dataset.color || "black";
          ctx.lineWidth = canvas.dataset.pencilSize ? parseInt(canvas.dataset.pencilSize) : 2;
          ctx.stroke();
        } else {
          draw(e.offsetX, e.offsetY);
        }
      });

      canvas.addEventListener("mouseup", (e) => {
        if (canvas.dataset.tool === "line") {
          stopDrawing(e.offsetX, e.offsetY);
        } else {
          drawing = false;
          finalizeStroke();
        }
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      });

      canvas.addEventListener("mouseleave", (e) => {
        if (drawing && canvas.dataset.tool === "line") {
          stopDrawing(e.offsetX, e.offsetY);
        } else {
          drawing = false;
        }
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      });

      ctx.lineCap = "round";
    }

    function clearWhiteboard(canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function stripLatex(latex) {
      return latex.replace(/\s+/g, '').replace(/\\left|\\right/g, '');
    }

    function checkAnswer(questionIndex) {
      const inputBox = document.getElementById(`answer-box-${questionIndex}`);
      const feedbackElement = document.getElementById(`feedback-${questionIndex}`);
      const attemptCounter = document.getElementById(`attempt-counter-${questionIndex}`);
      const studentAnswer = stripLatex(inputBox.value.trim());
      const possibleAnswers = questions[questionIndex].answers.map(answer => stripLatex(answer.toString().trim()));

      if (!questions[questionIndex].answered) {
        questions[questionIndex].attempts += 1;
        attemptCounter.textContent = `Attempts: ${questions[questionIndex].attempts}`;

        if (possibleAnswers.includes(studentAnswer)) {
          feedbackElement.textContent = "Correct!";
          feedbackElement.className = "feedback correct";
          questions[questionIndex].answered = true;
          correctAnswers++;
        } else if (questions[questionIndex].attempts >= 3) {
          const correctAnswersList = questions[questionIndex].answers;
          let answerString = correctAnswersList.length > 1 ? 
                             correctAnswersList.join(" \\text{ or } ") : 
                             correctAnswersList[0];
          feedbackElement.innerHTML = `Incorrect. The correct answer is: $$${answerString}$$`;
          feedbackElement.className = "feedback incorrect";
          MathJax.typeset();
          questions[questionIndex].answered = true;
        } else {
          feedbackElement.textContent = "Incorrect, try again.";
          feedbackElement.className = "feedback incorrect";
        }
      }
      updateScore();
    }

    function updateScore() {
      correctScoreElement.textContent = correctAnswers;
      totalQuestionsElement.textContent = questions.length;
      const percentage = ((correctAnswers / questions.length) * 100).toFixed(2);
      percentageScoreElement.textContent = `${percentage}%`;
    }

    function updateQuestionNumbers() {
      totalQuestionsElement.textContent = questions.length;
    }

    // Sample questions
    createQuestion(
      "A damsel is in distress and is being held captive in a tower. Her knight in shining armor is on the ground below with a ladder. When the knight stands 15 feet from the base of the tower and looks up at his precious damsel, the angle of elevation to her window is 60 degrees. How long does the ladder have to be?",
      ["30"]
    );

    createQuestion(
      "You are 200 yards from a river. Rather than walking directly to the river, you walk 400 yards along a straight path to the river’s edge. Find the acute angle between the path and the river’s edge.",
      ["30"]
    );

    createQuestion(
      "A 12-meter flagpole casts a 9-meter shadow. Find the angle of elevation of the sun.",
      ["53.1"]
    );

    createQuestion(
      "Suppose you’re flying a kite, and it gets caught at the top of a tree. You’ve let out all 100 feet of string for the kite, and the angle that the string makes with the ground is 75 degrees. Instead of worrying about how to get your kite back, you wonder: “How tall is that tree?”",
      ["96.6"]
    );

    createQuestion(
      "A submersible traveling at a depth of 250 feet dives at an angle of \\( 15^{\\circ} \\) with respect to a line parallel to the water’s surface. It travels a horizontal distance of 1500 feet during the dive. What is the depth of the submersible after the dive? (to the nearest whole number)",
      ["652"]
    );

    createQuestion(
      "A fire department’s longest ladder is 110 feet long, and the safety regulation states that they can use it for rescues up to 100 feet off the ground. What is the maximum safe angle of elevation for the rescue ladder?",
      ["65.4"]
    );

    createQuestion(
      "Brothers Bob and Tom Katz buy a tent that has a center pole 6.25 feet high. If the sides of the tent are supposed to make a \\( 50^{\\circ} \\) angle with the ground, how wide is the tent?",
      ["10.5"]
    );

    createQuestion(
      "A helicopter is hovering at a constant altitude of 900 meters. The pilot spots the top of a 60-meter-tall radio tower at an angle of depression of 8°. Determine the horizontal distance between the helicopter and the tower.",
      ["5976.9"]
    );

    createQuestion(
      "A lighthouse stands on a rocky cliff, making the top of the lighthouse 85 meters above sea level. The keeper at the top spots a fishing boat at an angle of depression of 10°, while a person standing on the shore at sea level between the boat and lighthouse observes the top of the lighthouse at an angle of elevation of 20°. Find the total distance from the fishing boat to the person on the shore.",
      ["248.5"]
    );

    createQuestion(
      "A drone is hovering 250 meters above the ground. One observer sees the drone at a 28° angle of elevation, while another observer on the opposite side (at the same ground level) sees it at a 22° angle of elevation. Determine how far apart the two observers are on the ground.",
      ["1089.0","1089"]
    );

    createQuestion(
      "A roller coaster reaches a maximum height of 50 meters above the ground. At first, a person on the ground measures a 40° angle of elevation to this highest point. Later, the rider at the top sees the person on the ground at a 12° angle of depression. How far did the observer move between the two measurements?",
      ["175.6"]
    );

    createQuestion(
      "A person standing near the base of a tall building measures the angle of elevation from the ground to the top of the building as \\( 42^{\\circ} \\). The person then walks 400 feet straight back and measures the new angle of elevation to be \\( 22^{\\circ} \\). How tall is the building?",
      ["293.2"]
    );

    createQuestion(
      "A hot air balloon is floating 300m above the ground. It is attached by 2 wires on either side to stop it flying away. If one wire has an angle of elevation of \\(25^{\\circ}\\) and the other an angle of \\(40^{\\circ}\\). What is the total length of wire needed?",
      ["1176.6"]
    );

    window.onload = function () {
      MathJax.typeset();
    };
  </script>
</body>
</html>
